{
  "hash": "a7d1d4c523def657e55b94b720f1204e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Spatial Dynamics of Sweetgreen and Chipotle Locations: Proximity or Competition?\"\nsubtitle: \"DSAN 6750 / PPOL 6805: GIS for Spatial Data Science\"\nauthors:\n  - name: Bella Shi\n    email: js5081@georgetown.edu\n    affiliation: Georgetown University\n    corresponding: true  \n  - name: Jacky Zhang\n    email: jz922@georgetown.edu\n    affiliation: Georgetown University\n    corresponding: true  \n  - name: Lianghui Yi\n    email: ly297@georgetown.edu\n    affiliation: Georgetown University\n    corresponding: true    \ndf-print: kable\ntitle-block-banner: \"#E69F0095\"\ntitle-block-banner-color: \"black\"\ncode-fold: true\nformat:\n  html:\n    df-print: kable\n  pdf:\n    link-citations: true \nprefer-html: true\n---\n\n:::{#2d315aac .cell .markdown}\n## Introduction\n\nThis project investigates whether the spatial distributions of Sweetgreen and Chipotle locations in the United States are correlated. We test if the chains cluster together (suggesting direct competition) or show patterns of spatial repulsion. Our hypothesis is:\n\n- $\\mathcal{H}_0$: Sweetgreen and Chipotle locations are randomly distributed with no spatial correlation.\n\n\n- $\\mathcal{H}_A$: Sweetgreen and Chipotle locations are spatially correlated (either clustering or repelling).\n\n\n## Methodology\n\nWe employ spatial analysis tools and a Monte Carlo simulation to assess spatial correlation. Using a spatial lag model and randomization tests, we compare observed distances between Sweetgreen and Chipotle locations with a distribution of distances under randomized placement of Chipotle locations.\n\nKey Steps:\n\n\t1.\tData Collection & Geocoding: Using the Google Places API to gather restaurant coordinates.\n\t2.\tExploratory Data Analysis: Mapping and visualizing the distributions.\n\t3.\tMonte Carlo Simulation: Testing whether observed proximity differs from random expectations.\n\t4.\tStatistical Tests: Conducting a one-sample t-test on the simulated distribution to determine significance.\n\n\n## Collecting Data\n\nBelow is an example snippet showing how we used the Google Places API to collect locations. We save outputs in GeoJSON, GeoPackage, and Shapefile formats. (Actual API keys and code omitted for brevity.)\n:::\n\n::: {#data_collection .cell execution_count=1}\n``` {.python .cell-code .hidden}\n# Access the API key\n# api_key = config.API_KEY.strip(\"'\")\n\nimport os\nimport requests\nimport geopandas as gpd\nfrom shapely.geometry import Point\n\n\ndef get_places(api_key, query, location=None, radius=None, max_results=100):\n    \"\"\"\n    Fetch places from Google Maps API based on a query, handling pagination.\n    \n    Parameters:\n        api_key (str): Google Maps API key.\n        query (str): Text search query (e.g., 'Sweetgreen in Washington DC').\n        location (str): Latitude,longitude string for search center.\n        radius (int): Search radius in meters.\n        max_results (int): Maximum number of results to fetch.\n        \n    Returns:\n        list: List of places returned by the API.\n    \"\"\"\n    base_url = 'https://maps.googleapis.com/maps/api/place/textsearch/json'\n    params = {\n        'query': query,\n        'key': api_key,\n        'location': location,\n        'radius': radius,\n    }\n    all_places = []\n    next_page_token = None\n\n    while len(all_places) < max_results:\n        if next_page_token:\n            params['pagetoken'] = next_page_token\n        \n        try:\n            response = requests.get(base_url, params=params)\n            response.raise_for_status()\n            data = response.json()\n\n            if 'results' in data:\n                all_places.extend(data['results'])\n\n            next_page_token = data.get('next_page_token')\n            if not next_page_token:\n                break  # No more pages available\n        except requests.exceptions.RequestException as e:\n            print(f\"Error fetching places: {e}\")\n            break\n    \n    return all_places[:max_results]\n\n\ndef save_places_to_formats(places, output_prefix=\"places\", file_suffix=\"\"):\n    \"\"\"\n    Save places to GeoJSON, GeoPackage, and Shapefile formats with customizable file names.\n    \n    Parameters:\n        places (list): List of place dictionaries from the Google Places API.\n        output_prefix (str): Prefix for the output files (e.g., directory or base name).\n        file_suffix (str): Custom suffix for file names (e.g., \"_DC\" or \"_2024\").\n    \"\"\"\n    if not places:\n        print(\"No valid places found to save.\")\n        return\n\n    # Convert places to a GeoDataFrame\n    data = []\n    for place in places:\n        name = place.get('name', 'N/A')\n        address = place.get('formatted_address', 'N/A')\n        location = place.get('geometry', {}).get('location', {})\n        lat = location.get('lat')\n        lng = location.get('lng')\n        if lat is not None and lng is not None:\n            data.append({\n                'name': name,\n                'address': address,\n                'latitude': lat,\n                'longitude': lng,\n                'geometry': Point(lng, lat)\n            })\n\n    # Create GeoDataFrame\n    gdf = gpd.GeoDataFrame(data, crs=\"EPSG:4326\")\n\n    # Customize file names\n    geojson_path = f\"{output_prefix}_geojson{file_suffix}.geojson\"\n    geopackage_path = f\"{output_prefix}_geopackage{file_suffix}.gpkg\"\n    shapefile_path = f\"{output_prefix}_shapefile{file_suffix}.shp\"\n\n    # Ensure output directories exist\n    os.makedirs(os.path.dirname(output_prefix), exist_ok=True)\n\n    # Save files with error handling\n    file_formats = [\n        (geojson_path, \"GeoJSON\", \"GeoJSON\"),\n        (geopackage_path, \"GPKG\", \"GeoPackage\"),\n        (shapefile_path, \"ESRI Shapefile\", \"Shapefile\"),\n    ]\n\n    for path, driver, label in file_formats:\n        try:\n            if driver == \"GPKG\":\n                gdf.to_file(path, layer=\"places\", driver=driver)\n            else:\n                gdf.to_file(path, driver=driver)\n            print(f\"Saved {label} to {path}\")\n        except Exception as e:\n            print(f\"Error saving {label}: {e}\")\n\n\n\n# Example usage\nif __name__ == \"__main__\":\n    query = 'Sweetgreen in Washington DC'\n    output_prefix = \"output/sweetgreen_locations\"\n    file_suffix = \"_2024\"\n    api_key = \"AIzaSyCcd3-C2h-GutmGdeo2B2vVtDFwVVd3-EU\"\n\n\n    # Fetch places\n    places = get_places(api_key, query, max_results=200)\n    print(f\"Fetched {len(places)} places.\")\n\n    # Save results\n    save_places_to_formats(places, output_prefix, file_suffix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFetched 18 places.\nSaved GeoJSON to output/sweetgreen_locations_geojson_2024.geojson\nSaved GeoPackage to output/sweetgreen_locations_geopackage_2024.gpkg\nSaved Shapefile to output/sweetgreen_locations_shapefile_2024.shp\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code .hidden}\nif __name__ == \"__main__\":\n    query = 'chipotle in Washington DC'\n    output_prefix = \"output/chipotle_locations\"\n    file_suffix = \"_2024\"\n\n    # Fetch places\n    places = get_places(api_key, query, max_results=200)\n    print(f\"Fetched {len(places)} places.\")\n\n    # Save results\n    save_places_to_formats(places, output_prefix, file_suffix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFetched 20 places.\nSaved GeoJSON to output/chipotle_locations_geojson_2024.geojson\nSaved GeoPackage to output/chipotle_locations_geopackage_2024.gpkg\nSaved Shapefile to output/chipotle_locations_shapefile_2024.shp\n```\n:::\n:::\n\n\n:::{#bf898fc8 .cell .markdown}\n## Preprocessing Data\n:::\n\n::: {#data_preprocessing .cell depends_on='data_collection' execution_count=3}\n``` {.python .cell-code .hidden}\nfrom scipy.spatial import distance_matrix\nimport numpy as np\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\n# Load data\nchipotle_gdf = gpd.read_file(\"output/chipotle_locations_geojson_2024.geojson\")  # Chipotle locations\nsweetgreen_gdf = gpd.read_file(\"output/sweetgreen_locations_geojson_2024.geojson\")\n\n# Ensure CRS matches\nchipotle_gdf = chipotle_gdf.to_crs(sweetgreen_gdf.crs)\n```\n:::\n\n\n:::{#5682fc73 .cell .markdown}\n## Exploratory Data Analysis (EDA)\n\nAfter collecting data, we geocode and plot the locations. We create intensity maps and heatmaps to visually inspect spatial patterns.\n\n### Intensity Map of Sweetgreen and Chipotle Locations\n:::\n\n::: {.cell execution_count=4}\n``` {.python .cell-code .hidden}\nimport requests\nimport pandas as pd\n\ndef get_places(api_key, query, location=None, radius=5000):\n    \"\"\"\n    Fetch places from Google Maps API based on a query.\n    \"\"\"\n    base_url = 'https://maps.googleapis.com/maps/api/place/textsearch/json'\n    params = {\n        'query': query,\n        'key': api_key,\n        'location': location,  # Optional: e.g., '38.9072,-77.0369'\n        'radius': radius  # Search radius in meters\n    }\n\n    all_places = []\n    next_page_token = None\n\n    while True:\n        if next_page_token:\n            params['pagetoken'] = next_page_token\n\n        response = requests.get(base_url, params=params)\n        response.raise_for_status()\n        data = response.json()\n\n        if 'results' in data:\n            all_places.extend(data['results'])\n\n        next_page_token = data.get('next_page_token')\n        if not next_page_token:\n            break  # No more pages to fetch\n\n    # Return relevant fields\n    return [\n        {\n            'name': place['name'],\n            'address': place.get('formatted_address', 'N/A'),\n            'lat': place['geometry']['location']['lat'],\n            'lng': place['geometry']['location']['lng']\n        }\n        for place in all_places\n    ]\n\n# Example API usage\nsweetgreen_places = get_places(api_key, 'Sweetgreen in Washington DC')\nchipotle_places = get_places(api_key, 'Chipotle in Washington DC')\n\n# Convert results to DataFrames\nsweetgreen_df = pd.DataFrame(sweetgreen_places)\nchipotle_df = pd.DataFrame(chipotle_places)\n\nimport folium\n\n# Create a base map centered around Washington, D.C.\nmap_center = [38.9072, -77.0369]  # Latitude, Longitude\nm = folium.Map(location=map_center, zoom_start=13)\n\n# Add Sweetgreen locations to the map\nfor _, row in sweetgreen_df.iterrows():\n    folium.Marker(\n        location=[row['lat'], row['lng']],\n        popup=f\"Sweetgreen: {row['name']}<br>{row['address']}\",\n        icon=folium.Icon(color='green', icon='leaf')\n    ).add_to(m)\n\n# Add Chipotle locations to the map\nfor _, row in chipotle_df.iterrows():\n    folium.Marker(\n        location=[row['lat'], row['lng']],\n        popup=f\"Chipotle: {row['name']}<br>{row['address']}\",\n        icon=folium.Icon(color='orange', icon='cutlery')\n    ).add_to(m)\n\n# Save and display the map\nm.save(\"sweetgreen_chipotle_map.html\")\nm\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n<folium.folium.Map at 0x16a297350>\n```\n:::\n:::\n\n\n:::{#60114d78 .cell .markdown}\n### Heatmap of Sweetgreen and Chipotle Locations\n:::\n\n::: {.cell execution_count=5}\n``` {.python .cell-code .hidden}\nfrom folium.plugins import HeatMap\nimport folium\n\n# Create a base map centered on Washington, D.C.\nmap_center = [38.9072, -77.0369]  # Latitude, Longitude\nheatmap = folium.Map(location=map_center, zoom_start=12)\n\n# Prepare data for Sweetgreen heatmap (latitudes and longitudes)\nsweetgreen_heat_data = sweetgreen_df[['lat', 'lng']].values.tolist()\n\n# Add Sweetgreen HeatMap\nHeatMap(sweetgreen_heat_data, radius=15, gradient={0.2: 'blue', 0.5: 'lime', 0.8: 'red'}).add_to(heatmap)\n\n# Prepare data for Chipotle heatmap\nchipotle_heat_data = chipotle_df[['lat', 'lng']].values.tolist()\n\n# Add Chipotle HeatMap\nHeatMap(chipotle_heat_data, radius=15, gradient={0.2: 'purple', 0.5: 'orange', 0.8: 'yellow'}).add_to(heatmap)\n\n\n# Save the heatmap to an HTML file\nheatmap.save(\"sweetgreen_chipotle_heatmap.html\")\nheatmap\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n<folium.folium.Map at 0x16911f290>\n```\n:::\n:::\n\n\n:::{#113b853e .cell .markdown}\n## Hypothesis\n\n### Hypothesis:\n\n$\\mathcal{H}_0$: Sweetgreen and Chipotle locations are randomly distributed with no spatial correlation.\n\n$\\mathcal{H}_A$: SSweetgreen and Chipotle locations are spatially correlated (either clustering together (proximity) or repelling each other (competition)).\n\n\n### Monte Carlo Simulation\n\nTo test our hypothesis, we conduct a Monte Carlo simulation. We randomly distribute Sweetgreen and Chipotle locations on a map and calculate the distance between each pair of locations. We then compare the observed distance between Sweetgreen and Chipotle locations to the distribution of distances under the null hypothesis.\n\nSteps:\n\n1. Calculate observed distances between Sweetgreen and Chipotle using the minimum distance to a Chipotle for each Sweetgreen location.\n2. Randomize Chipotle locations within the bounding box (longitude-latitude range of original Chipotle locations).\n3. Repeat this process for the specified number of simulations, storing the average distance for each simulation.\n:::\n\n::: {.cell execution_count=6}\n``` {.python .cell-code .hidden}\nimport numpy as np\nfrom scipy.spatial import distance\nimport matplotlib.pyplot as plt\n\n# Monte Carlo Simulation to compare average distances between Sweetgreen and Chipotle\ndef monte_carlo_simulation(sweetgreen_coords, chipotle_coords, num_simulations=100000):\n    \"\"\"\n    Perform a Monte Carlo simulation to test the hypothesis:\n    Are the observed distances between Sweetgreen and Chipotle locations\n    significantly different from random placement?\n\n    Args:\n        sweetgreen_coords: Array of Sweetgreen coordinates.\n        chipotle_coords: Array of Chipotle coordinates.\n        num_simulations: Number of Monte Carlo simulations.\n\n    Returns:\n        Observed average distance, distribution of simulated distances.\n    \"\"\"\n    observed_distances = distance.cdist(sweetgreen_coords, chipotle_coords).min(axis=1)\n    observed_avg_distance = observed_distances.mean()\n\n    # Simulated distances\n    simulated_avg_distances = []\n\n    for _ in range(num_simulations):\n        # Randomize Chipotle locations within the bounding box\n        randomized_chipotle_coords = np.random.uniform(\n            low=[chipotle_coords[:, 0].min(), chipotle_coords[:, 1].min()],\n            high=[chipotle_coords[:, 0].max(), chipotle_coords[:, 1].max()],\n            size=chipotle_coords.shape\n        )\n        simulated_distances = distance.cdist(sweetgreen_coords, randomized_chipotle_coords).min(axis=1)\n        simulated_avg_distances.append(simulated_distances.mean())\n\n    return observed_avg_distance, simulated_avg_distances\n\n# Prepare data\nsweetgreen_coords = np.array(sweetgreen_df[['lng', 'lat']])\nchipotle_coords = np.array(chipotle_df[['lng', 'lat']])\n\n# Run Monte Carlo Simulation\nobserved_avg_distance, simulated_avg_distances = monte_carlo_simulation(\n    sweetgreen_coords, chipotle_coords, num_simulations=1000\n)\n\n# Plot the distribution of simulated distances and observed distance\nplt.figure(figsize=(10, 6))\nplt.hist(simulated_avg_distances, bins=30, color='blue', alpha=0.7, label=\"Simulated Avg Distances\")\nplt.axvline(observed_avg_distance, color='red', linestyle='--', linewidth=2, label=\"Observed Avg Distance\")\nplt.title(\"Monte Carlo Simulation: Sweetgreen-Chipotle Proximity\")\nplt.xlabel(\"Average Distance\")\nplt.ylabel(\"Frequency\")\nplt.legend()\nplt.show()\n\n# Print summary\nobserved_avg_distance, np.mean(simulated_avg_distances), np.std(simulated_avg_distances)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-pdf/cell-7-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::{#66848545 .cell .markdown}\n### KDE Plot of Sweetgreen and Chipotle Locations\n:::\n\n::: {.cell execution_count=7}\n``` {.python .cell-code .hidden}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Plot distances between Sweetgreen and Chipotle\nplt.figure(figsize=(10, 6))\nsns.kdeplot(simulated_avg_distances, color=\"blue\", label=\"Simulated Avg Distances\")\nplt.axvline(observed_avg_distance, color=\"red\", linestyle=\"--\", linewidth=2, label=\"Observed Avg Distance\")\nplt.title(\"Monte Carlo Simulation: Sweetgreen-Chipotle Proximity\")\nplt.xlabel(\"Average Distance\")\nplt.ylabel(\"Density\")\nplt.legend()\nplt.show()\n\n# Interpretation:\nif observed_avg_distance < np.mean(simulated_avg_distances):\n    print(\"The observed average distance is shorter than simulated distances. This suggests they are spatial corralated.\")\nelse:\n    print(\"The observed average distance is not significantly shorter. This suggests they are not spatial corralated.\")\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n```\n/Users/verkyyi/anaconda3/envs/dsan5400/lib/python3.11/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-pdf/cell-8-output-2.pdf){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nThe observed average distance is not significantly shorter. This suggests they are not spatial corralated.\n```\n:::\n:::\n\n\n:::{#6d244e30 .cell .markdown}\n#### One-Sample T-Test\n\nHypothesis:\n\n$\\mathcal{H}_0$: Sweetgreen and Chipotle locations are randomly distributed with no spatial correlation.\n\n$\\mathcal{H}_A$: Sweetgreen and Chipotle locations are spatially correlated (either clustering together (proximity) or repelling each other (competition).\n:::\n\n::: {.cell execution_count=8}\n``` {.python .cell-code .hidden}\nimport numpy as np\nfrom scipy.stats import ttest_1samp\n\n# # Example Data\n# print(simulated_avg_distances)\n# print(observed_avg_distance)\n\n# Perform a one-sample t-test\nt_stat, p_value = ttest_1samp(simulated_avg_distances, observed_avg_distance)\n\n# Print results\nprint(f\"T-statistic: {t_stat}\")\nprint(f\"P-value: {p_value}\")\n\n# Interpretation\nalpha = 0.05  # Significance level\nif p_value < alpha:\n    print(\"The observed average distance is significantly different from the simulated distances (reject H₀).\")\nelse:\n    print(\"The observed average distance is not significantly different from the simulated distances (fail to reject H₀).\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nT-statistic: -2.3336760738297295\nP-value: 0.01981027122504727\nThe observed average distance is significantly different from the simulated distances (reject H₀).\n```\n:::\n:::\n\n\n:::{#75c76e7d .cell .markdown}\n## Discussion\n\nIf the locations of Sweetgreen and Chipotle are spatially correlated, Are Sweetgreen and Chipotle locations clustered together (like in the Hotelling model)? Or are they evenly spaced across a city or region (like in the Salop model)?\n\n### 1. Hotelling Model (Linear City Model)\nConcept: Firms compete for customers along a single line (like a street, highway, or product spectrum). Customers are evenly distributed along the line and face \"transportation costs\" (effort, time, or money) to reach the firms.\n\nFirms tend to move closer together toward the center of the line (\"minimum differentiation\") to capture the largest customer base.\nThis \"clustering\" happens because if one firm moves away, it loses customers to its competitor.\nApplication to Sweetgreen vs. Chipotle:\nWe can use the Hotelling model to analyze whether these two chains are colocated (clustered) to maximize competition or spread out to dominate separate areas.\nThe average distances between Sweetgreen and Chipotle locations serve as a proxy for their competitive strategy.\n\n\n### 2. Salop Model (Circular City Model)\n\nConcept: Extends the Hotelling model to a circular city (like a city with multiple neighborhoodsor a ring road). The circular model is useful when more than two competitors exist, and it prevents boundary effects (e.g., firms clustering at the ends of a line).\n\nGoal: Firms aim to maximize market share by minimizing transportation costs for customers, similar to the Hotelling model, but in a circular (2D) representation.\n\nCustomers are evenly distributed around a circle.\nMultiple firms (e.g., Sweetgreen, Chipotle, Panera Bread) compete.\nCustomers pick the closest firm, incurring the lowest transportation cost.\nImplications:\nFirms tend to space themselves equally around the circle to avoid direct competition and capture their segment of the market.\nThis leads to \"maximum differentiation,\" where firms spread out rather than cluster together.\n\nSalop’s Model assumes businesses (like Sweetgreen and Chipotle) are evenly distributed on a circular market, leading to relatively equidistant placements.\nA low standard deviation in the closest distances (\nmin_distances\nmin_distances) would be consistent with this model, as it reflects uniform proximity to competitors.\n:::\n\n::: {.cell execution_count=9}\n``` {.python .cell-code .hidden}\n# Compute pairwise distances between Sweetgreen and Chipotle\npairwise_distances = distance.cdist(sweetgreen_coords, chipotle_coords)\n\n# Analyze distance distribution\nmin_distances = pairwise_distances.min(axis=1)  # Closest Chipotle for each Sweetgreen\nstd_dev_distances = min_distances.std()         # Spread of distances\n\nprint(f\"Standard Deviation of Min Distances: {std_dev_distances:.4f}\")\n\n# Interpretation:\nif std_dev_distances < 0.1 * min_distances.mean():  # Threshold relative to mean distance\n    print(\"Low standard deviation in distances suggests equidistant spread, consistent with Salop's Model.\")\nelse:\n    print(\"High standard deviation in distances suggests clustering or irregular spacing, not consistent with Salop's Model.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStandard Deviation of Min Distances: 0.0234\nHigh standard deviation in distances suggests clustering or irregular spacing, not consistent with Salop's Model.\n```\n:::\n:::\n\n\n:::{#192149dc .cell .markdown}\n### 3. Hotelling Model: Analyze Minimum Distances\n\nWe compute the average minimum distance from each Sweetgreen to the nearest Chipotle to assess clustering.\n:::\n\n::: {.cell execution_count=10}\n``` {.python .cell-code .hidden}\nfrom scipy.spatial import distance_matrix\nimport matplotlib.pyplot as plt\n\n# Calculate pairwise distances between Sweetgreen and Chipotle locations\ndistances = distance_matrix(\n    sweetgreen_gdf.geometry.apply(lambda geom: (geom.x, geom.y)).tolist(),\n    chipotle_gdf.geometry.apply(lambda geom: (geom.x, geom.y)).tolist()\n)\n\n# Find the minimum distance from each Sweetgreen to a Chipotle\nmin_distances = distances.min(axis=1)\navg_distance = min_distances.mean()\n\nprint(f\"Average minimum distance between Sweetgreen and Chipotle: {avg_distance:.2f} miles\")\n\n# Plot histogram of distances\nplt.hist(min_distances, bins=10, color='green', alpha=0.7)\nplt.title(\"Minimum Distances from Sweetgreen to Chipotle\")\nplt.xlabel(\"Distance (miles)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAverage minimum distance between Sweetgreen and Chipotle: 0.01 miles\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-pdf/cell-11-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::{#8944a46b .cell .markdown}\nUse minimum distances between Sweetgreen and Chipotle to assess clustering or separation.\n\nA smaller average distance indicates clustering (competitive strategy).\n\n### 4. Salop Model: Voronoi Diagram for Market Coverage\n\nWe compute the Voronoi diagram to visualize how Sweetgreen and Chipotle locations partition space and analyze their spatial distribution.\n:::\n\n::: {.cell execution_count=11}\n``` {.python .cell-code .hidden}\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nimport numpy as np\n\n# Combine Sweetgreen and Chipotle coordinates\ncombined_coords = np.vstack((\n    sweetgreen_gdf.geometry.apply(lambda geom: (geom.x, geom.y)).tolist(),\n    chipotle_gdf.geometry.apply(lambda geom: (geom.x, geom.y)).tolist()\n))\n\n# Compute Voronoi diagram\nvor = Voronoi(combined_coords)\n\n# Plot Voronoi diagram\nfig, ax = plt.subplots(figsize=(10, 8))\nvoronoi_plot_2d(vor, ax=ax, show_vertices=False, line_colors='gray')\nsweetgreen_gdf.plot(ax=ax, color='green', label='Sweetgreen', markersize=50)\nchipotle_gdf.plot(ax=ax, color='orange', label='Chipotle', markersize=50)\nplt.legend()\nplt.title(\"Voronoi Diagram for Sweetgreen and Chipotle Locations\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-pdf/cell-12-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::{#bf2f1922 .cell .markdown}\nUse Voronoi diagrams to assess market partitioning and spatial competition.\nEqual partitioning suggests maximum differentiation, while overlap indicates clustering.\n\n## Conclusion\n\nSweetgreen and Chipotle are not randomly distributed. Their locations exhibit spatial correlation, indicating strategic positioning. Policymakers and businesses should consider these patterns when shaping food environments, as they may influence consumer choices and community health outcomes.\n:::\n\n",
    "supporting": [
      "index_files/figure-pdf"
    ],
    "filters": []
  }
}